// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: relationship.sql

package db

import (
	"context"
)

const listChildrenEntities = `-- name: ListChildrenEntities :many
SELECT relationship.relationship_id, relationship.source_entity_id, relationship.target_entity_id, relationship.relationship_type_id,
  relationship_type.relationship_type_name,
  entity.entity_name,
  entity_type.entity_type_name
FROM relationship
  INNER JOIN relationship_type ON relationship.relationship_type_id = relationship_type.relationship_type_id
  INNER JOIN entity ON relationship.target_entity_id = entity.entity_id
  INNER JOIN entity_type ON entity.entity_type_id = entity_type.entity_type_id
WHERE source_entity_id = ?1
LIMIT ?3 OFFSET ?2
`

type ListChildrenEntitiesParams struct {
	EntityID int64
	Offset   int64
	Limit    int64
}

type ListChildrenEntitiesRow struct {
	RelationshipID       int64
	SourceEntityID       int64
	TargetEntityID       int64
	RelationshipTypeID   int64
	RelationshipTypeName string
	EntityName           string
	EntityTypeName       string
}

func (q *Queries) ListChildrenEntities(ctx context.Context, arg ListChildrenEntitiesParams) ([]ListChildrenEntitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listChildrenEntities, arg.EntityID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListChildrenEntitiesRow{}
	for rows.Next() {
		var i ListChildrenEntitiesRow
		if err := rows.Scan(
			&i.RelationshipID,
			&i.SourceEntityID,
			&i.TargetEntityID,
			&i.RelationshipTypeID,
			&i.RelationshipTypeName,
			&i.EntityName,
			&i.EntityTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listParentEntities = `-- name: ListParentEntities :many
SELECT relationship.relationship_id, relationship.source_entity_id, relationship.target_entity_id, relationship.relationship_type_id,
  relationship_type.relationship_type_name,
  entity.entity_name,
  entity_type.entity_type_name
FROM relationship
  INNER JOIN relationship_type ON relationship.relationship_type_id = relationship_type.relationship_type_id
  INNER JOIN entity ON relationship.source_entity_id = entity.entity_id
  INNER JOIN entity_type ON relationship.source_entity_type_id = entity_type.entity_type_id
WHERE target_entity_id = ?1
LIMIT ?3 OFFSET ?2
`

type ListParentEntitiesParams struct {
	EntityID int64
	Offset   int64
	Limit    int64
}

type ListParentEntitiesRow struct {
	RelationshipID       int64
	SourceEntityID       int64
	TargetEntityID       int64
	RelationshipTypeID   int64
	RelationshipTypeName string
	EntityName           string
	EntityTypeName       string
}

func (q *Queries) ListParentEntities(ctx context.Context, arg ListParentEntitiesParams) ([]ListParentEntitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listParentEntities, arg.EntityID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListParentEntitiesRow{}
	for rows.Next() {
		var i ListParentEntitiesRow
		if err := rows.Scan(
			&i.RelationshipID,
			&i.SourceEntityID,
			&i.TargetEntityID,
			&i.RelationshipTypeID,
			&i.RelationshipTypeName,
			&i.EntityName,
			&i.EntityTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRelationships = `-- name: ListRelationships :many
SELECT relationship.relationship_id, relationship.source_entity_id, relationship.target_entity_id, relationship.relationship_type_id,
  relationship_type.relationship_type_name,
  source_entity.entity_name AS source_entity_name,
  source_entity_type.entity_type_name AS source_entity_type_name,
  target_entity.entity_name AS target_entity_name,
  target_entity_type.entity_type_name AS target_entity_type_name
FROM relationship
  INNER JOIN source_entity ON relationship.source_entity_id = source_entity.entity_id
  INNER JOIN target_entity ON relationship.target_entity_id = target_entity.entity_id
  INNER JOIN relationship_type ON relationship.relationship_type_id = relationship_type.relationship_type_id
  INNER JOIN source_entity_type ON source_entity.entity_type_id = source_entity_type.entity_type_id
  INNER JOIN target_entity_type ON target_entity.entity_type_id = target_entity_type.entity_type_id
LIMIT ?2 OFFSET ?1
`

type ListRelationshipsParams struct {
	Offset int64
	Limit  int64
}

type ListRelationshipsRow struct {
	RelationshipID       int64
	SourceEntityID       int64
	TargetEntityID       int64
	RelationshipTypeID   int64
	RelationshipTypeName string
	SourceEntityName     string
	SourceEntityTypeName string
	TargetEntityName     string
	TargetEntityTypeName string
}

func (q *Queries) ListRelationships(ctx context.Context, arg ListRelationshipsParams) ([]ListRelationshipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listRelationships, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRelationshipsRow{}
	for rows.Next() {
		var i ListRelationshipsRow
		if err := rows.Scan(
			&i.RelationshipID,
			&i.SourceEntityID,
			&i.TargetEntityID,
			&i.RelationshipTypeID,
			&i.RelationshipTypeName,
			&i.SourceEntityName,
			&i.SourceEntityTypeName,
			&i.TargetEntityName,
			&i.TargetEntityTypeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
